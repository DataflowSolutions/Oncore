/**
 * RLS Security Vulnerability Tests
 * Tests for common Row Level Security vulnerabilities and exploits
 * 
 * This suite tests for:
 * - Unauthorized data access across organizations
 * - SQL injection attempts
 * - Privilege escalation
 * - Data leakage through joins
 * - Bypass attempts using service role
 */

import { dbManager } from '../config/database-config'
import { createClient } from '@supabase/supabase-js'
import { performance } from 'perf_hooks'

interface TestResult {
  testName: string
  passed: boolean
  duration: number
  details?: string
  severity?: 'critical' | 'high' | 'medium' | 'low'
}

class RLSSecurityTest {
  private results: TestResult[] = []
  private criticalFailures = 0

  async run() {
    console.log('ğŸ”’ RLS Security Vulnerability Tests')
    dbManager.printConfig()

    // Run all security tests
    await this.testCrossOrganizationAccess()
    await this.testUnauthorizedShowAccess()
    await this.testUnauthorizedVenueAccess()
    await this.testUnauthorizedArtistAccess()
    await this.testUnauthorizedPeopleAccess()
    await this.testSQLInjectionAttempts()
    await this.testPrivilegeEscalation()
    await this.testJoinBasedDataLeakage()
    await this.testUnauthenticatedAccess()
    await this.testServiceRoleBypass()
    await this.testBulkDataExfiltration()
    await this.testCrossOrgCollaboration()

    this.printResults()

    // Exit with error if critical failures
    if (this.criticalFailures > 0) {
      console.error(`\nâŒ CRITICAL: ${this.criticalFailures} critical security vulnerabilities found!`)
      process.exit(1)
    }
  }

  private async testSecurely(
    name: string,
    severity: 'critical' | 'high' | 'medium' | 'low',
    fn: () => Promise<void>
  ): Promise<void> {
    const start = performance.now()
    try {
      await fn()
      const duration = performance.now() - start
      this.results.push({ testName: name, passed: true, duration, severity })
      console.log(`  âœ… ${name} (${duration.toFixed(2)}ms)`)
    } catch (error) {
      const duration = performance.now() - start
      const details = error instanceof Error ? error.message : String(error)
      this.results.push({ testName: name, passed: false, duration, details, severity })
      console.log(`  âŒ ${name} (${duration.toFixed(2)}ms)`)
      console.log(`     ${details}`)
      
      if (severity === 'critical' || severity === 'high') {
        this.criticalFailures++
      }
    }
  }

  /**
   * Test 1: Cross-Organization Data Access
   * Users should NEVER see data from organizations they don't belong to
   */
  async testCrossOrganizationAccess() {
    console.log('\nğŸ” Test 1: Cross-Organization Data Access Prevention')
    console.log('-'.repeat(70))

    const serviceClient = dbManager.getServiceRoleClient()

    // Create two test organizations
    const { data: org1 } = await serviceClient
      .from('organizations')
      .insert({ name: 'Test Org 1 Security Test' })
      .select()
      .single()

    const { data: org2 } = await serviceClient
      .from('organizations')
      .insert({ name: 'Test Org 2 Security Test' })
      .select()
      .single()

    if (!org1 || !org2) {
      console.log('  âš ï¸  Skipping: Cannot create test organizations')
      return
    }

    try {
      // Create test users
      const user1 = await dbManager.createTestUser(
        `test-user1-${Date.now()}@example.com`,
        'password123'
      )

      const user2 = await dbManager.createTestUser(
        `test-user2-${Date.now()}@example.com`,
        'password123'
      )

      // Add user1 to org1
      await serviceClient.from('org_members').insert({
        org_id: org1.id,
        user_id: user1.user.id,
        role: 'member'
      })

      // Add user2 to org2
      await serviceClient.from('org_members').insert({
        org_id: org2.id,
        user_id: user2.user.id,
        role: 'member'
      })

      // Create a show in org1
      const { data: show1 } = await serviceClient
        .from('shows')
        .insert({
          org_id: org1.id,
          title: 'Secret Show Org 1',
          date: '2025-12-01',
          venue_id: null
        })
        .select()
        .single()

      await this.testSecurely(
        'User from Org 2 cannot access Org 1 shows',
        'critical',
        async () => {
          const { data, error } = await user2.client
            .from('shows')
            .select('*')
            .eq('id', show1!.id)
            .single()

          // Should get no data or an error
          if (data && !error) {
            throw new Error('âŒ VULNERABILITY: User accessed cross-org data!')
          }
        }
      )

      await this.testSecurely(
        'User from Org 2 cannot access Org 1 organization details',
        'critical',
        async () => {
          const { data, error } = await user2.client
            .from('organizations')
            .select('*')
            .eq('id', org1!.id)
            .single()

          if (data && !error) {
            throw new Error('âŒ VULNERABILITY: User accessed other organization!')
          }
        }
      )

      await this.testSecurely(
        'User from Org 1 cannot modify Org 2 data',
        'critical',
        async () => {
          const { error } = await user1.client
            .from('organizations')
            .update({ name: 'HACKED' })
            .eq('id', org2!.id)

          if (!error) {
            throw new Error('âŒ VULNERABILITY: User modified cross-org data!')
          }
        }
      )
    } finally {
      // Cleanup
      if (!dbManager.isProduction()) {
        await serviceClient.from('shows').delete().eq('org_id', org1.id)
        await serviceClient.from('org_members').delete().eq('org_id', org1.id)
        await serviceClient.from('org_members').delete().eq('org_id', org2.id)
        await serviceClient.from('organizations').delete().eq('id', org1.id)
        await serviceClient.from('organizations').delete().eq('id', org2.id)
      }
    }
  }

  /**
   * Test 2: Unauthorized Show Access
   */
  async testUnauthorizedShowAccess() {
    console.log('\nğŸ­ Test 2: Unauthorized Show Access')
    console.log('-'.repeat(70))

    await this.testSecurely(
      'Anonymous users cannot access shows',
      'high',
      async () => {
        const anonClient = dbManager.getAnonClient()
        const { data } = await anonClient
          .from('shows')
          .select('*')
          .limit(1)

        // With RLS, should return empty or error
        if (data && data.length > 0) {
          throw new Error('Anonymous user can access shows!')
        }
      }
    )

    await this.testSecurely(
      'Users cannot insert shows without org membership',
      'high',
      async () => {
        const { client } = await dbManager.createTestUser()
        const { error } = await client
          .from('shows')
          .insert({
            title: 'Unauthorized Show',
            date: '2025-12-01',
            org_id: '00000000-0000-0000-0000-000000000000'
          })

        if (!error) {
          throw new Error('User inserted show without org membership!')
        }
      }
    )
  }

  /**
   * Test 3: Unauthorized Venue Access
   */
  async testUnauthorizedVenueAccess() {
    console.log('\nğŸ›ï¸  Test 3: Unauthorized Venue Access')
    console.log('-'.repeat(70))

    await this.testSecurely(
      'Users cannot access venues from other organizations',
      'high',
      async () => {
        const serviceClient = dbManager.getServiceRoleClient()
        
        // Create test org and venue
        const { data: org } = await serviceClient
          .from('organizations')
          .insert({ name: 'Venue Test Org' })
          .select()
          .single()

        if (!org) return

        const { data: venue } = await serviceClient
          .from('venues')
          .insert({
            org_id: org.id,
            name: 'Secret Venue',
            city: 'TestCity'
          })
          .select()
          .single()

        try {
          // Create user NOT in org
          const { client } = await dbManager.createTestUser(
            `venue-test-${Date.now()}@example.com`
          )

          const { data } = await client
            .from('venues')
            .select('*')
            .eq('id', venue!.id)
            .single()

          if (data) {
            throw new Error('User accessed venue from different org!')
          }
        } finally {
          if (!dbManager.isProduction()) {
            await serviceClient.from('venues').delete().eq('id', venue!.id)
            await serviceClient.from('organizations').delete().eq('id', org.id)
          }
        }
      }
    )
  }

  /**
   * Test 4: Unauthorized Artist Access
   */
  async testUnauthorizedArtistAccess() {
    console.log('\nğŸ¤ Test 4: Unauthorized Artist Access')
    console.log('-'.repeat(70))

    await this.testSecurely(
      'Users cannot modify artists from other organizations',
      'medium',
      async () => {
        const serviceClient = dbManager.getServiceRoleClient()
        
        const { data: org } = await serviceClient
          .from('organizations')
          .insert({ name: 'Artist Test Org' })
          .select()
          .single()

        if (!org) return

        const { data: artist } = await serviceClient
          .from('artists')
          .insert({
            org_id: org.id,
            name: 'Secret Artist'
          })
          .select()
          .single()

        try {
          const { client } = await dbManager.createTestUser(
            `artist-test-${Date.now()}@example.com`
          )

          const { error } = await client
            .from('artists')
            .update({ name: 'HACKED ARTIST' })
            .eq('id', artist!.id)

          if (!error) {
            throw new Error('User modified artist from different org!')
          }
        } finally {
          if (!dbManager.isProduction()) {
            await serviceClient.from('artists').delete().eq('id', artist!.id)
            await serviceClient.from('organizations').delete().eq('id', org.id)
          }
        }
      }
    )
  }

  /**
   * Test 5: Unauthorized People/Contact Access
   */
  async testUnauthorizedPeopleAccess() {
    console.log('\nğŸ‘¥ Test 5: Unauthorized People Access')
    console.log('-'.repeat(70))

    await this.testSecurely(
      'Users cannot access people from other organizations',
      'high',
      async () => {
        const serviceClient = dbManager.getServiceRoleClient()
        
        const { data: org } = await serviceClient
          .from('organizations')
          .insert({ name: 'People Test Org' })
          .select()
          .single()

        if (!org) return

        const { data: person } = await serviceClient
          .from('people')
          .insert({
            org_id: org.id,
            name: 'Secret Contact',
            email: 'secret@example.com'
          })
          .select()
          .single()

        try {
          const { client } = await dbManager.createTestUser(
            `people-test-${Date.now()}@example.com`
          )

          const { data } = await client
            .from('people')
            .select('*')
            .eq('id', person!.id)
            .single()

          if (data) {
            throw new Error('User accessed contact from different org!')
          }
        } finally {
          if (!dbManager.isProduction()) {
            await serviceClient.from('people').delete().eq('id', person!.id)
            await serviceClient.from('organizations').delete().eq('id', org.id)
          }
        }
      }
    )
  }

  /**
   * Test 6: SQL Injection Attempts
   */
  async testSQLInjectionAttempts() {
    console.log('\nğŸ’‰ Test 6: SQL Injection Prevention')
    console.log('-'.repeat(70))

    const injectionPayloads = [
      "'; DROP TABLE shows; --",
      "1' OR '1'='1",
      "1' UNION SELECT * FROM organizations--",
      "admin'--",
      "1'; DELETE FROM shows WHERE '1'='1"
    ]

    for (const payload of injectionPayloads) {
      await this.testSecurely(
        `SQL Injection attempt: ${payload.substring(0, 30)}...`,
        'critical',
        async () => {
          const { client } = await dbManager.createTestUser()
          
          // Try injection in various fields
          const { error } = await client
            .from('shows')
            .select('*')
            .eq('title', payload)
            .limit(1)

          // Should handle gracefully (not leak data or crash)
          // The test passes if we don't throw an error
        }
      )
    }
  }

  /**
   * Test 7: Privilege Escalation
   */
  async testPrivilegeEscalation() {
    console.log('\nâ¬†ï¸  Test 7: Privilege Escalation Prevention')
    console.log('-'.repeat(70))

    await this.testSecurely(
      'Member cannot promote themselves to admin',
      'critical',
      async () => {
        const serviceClient = dbManager.getServiceRoleClient()
        
        const { data: org } = await serviceClient
          .from('organizations')
          .insert({ name: 'Privilege Test Org' })
          .select()
          .single()

        if (!org) return

        const { client, user } = await dbManager.createTestUser(
          `priv-test-${Date.now()}@example.com`
        )

        // Add as member
        await serviceClient.from('org_members').insert({
          org_id: org.id,
          user_id: user.id,
          role: 'member'
        })

        try {
          // Try to escalate to admin
          const { error } = await client
            .from('org_members')
            .update({ role: 'admin' })
            .eq('user_id', user.id)

          if (!error) {
            throw new Error('User escalated their own privileges!')
          }
        } finally {
          if (!dbManager.isProduction()) {
            await serviceClient.from('org_members').delete().eq('org_id', org.id)
            await serviceClient.from('organizations').delete().eq('id', org.id)
          }
        }
      }
    )
  }

  /**
   * Test 8: Join-Based Data Leakage
   */
  async testJoinBasedDataLeakage() {
    console.log('\nğŸ”— Test 8: Join-Based Data Leakage')
    console.log('-'.repeat(70))

    await this.testSecurely(
      'Users cannot leak data through nested joins',
      'high',
      async () => {
        const { client } = await dbManager.createTestUser()
        
        // Try to access data through joins
        const { data } = await client
          .from('shows')
          .select(`
            *,
            organizations (
              *,
              org_members (*)
            )
          `)
          .limit(10)

        // If user is not in any org, should get no data
        // If in an org, should only see that org's data
        if (data && data.length > 0) {
          // Check that all returned data belongs to user's orgs
          // This is a simplified check
          console.log(`    Found ${data.length} shows (expected: only user's orgs)`)
        }
      }
    )
  }

  /**
   * Test 9: Unauthenticated Access
   */
  async testUnauthenticatedAccess() {
    console.log('\nğŸš« Test 9: Unauthenticated Access Prevention')
    console.log('-'.repeat(70))

    const tables = ['shows', 'venues', 'artists', 'people', 'organizations', 'org_members']

    for (const table of tables) {
      await this.testSecurely(
        `Unauthenticated access to ${table} is blocked`,
        'critical',
        async () => {
          // Create a fresh anonymous client for each test (not cached)
          const config = dbManager.getConfig()
          const anonClient = createClient(config.url, config.anonKey)
          
          const { data } = await anonClient
            .from(table)
            .select('*')
            .limit(1)

          if (data && data.length > 0) {
            throw new Error(`Unauthenticated user accessed ${table}!`)
          }
        }
      )
    }
  }

  /**
   * Test 10: Service Role Bypass Prevention
   */
  async testServiceRoleBypass() {
    console.log('\nğŸ”‘ Test 10: Service Role Bypass Prevention')
    console.log('-'.repeat(70))

    await this.testSecurely(
      'Regular users cannot bypass RLS with auth headers',
      'critical',
      async () => {
        const config = dbManager.getConfig()
        const { client, session } = await dbManager.createTestUser()

        // Try to use service role key with user session
        // This should NOT work
        try {
          const { data } = await client
            .from('organizations')
            .select('*')
            // Attempt to use service role (this shouldn't work)

          // Test passes if we can't access all orgs
          if (data && data.length > 10) {
            throw new Error('User bypassed RLS!')
          }
        } catch (error) {
          // Expected to fail
        }
      }
    )
  }

  /**
   * Test 11: Bulk Data Exfiltration
   */
  async testBulkDataExfiltration() {
    console.log('\nğŸ“¦ Test 11: Bulk Data Exfiltration Prevention')
    console.log('-'.repeat(70))

    await this.testSecurely(
      'Users cannot exfiltrate all database records',
      'high',
      async () => {
        const { client } = await dbManager.createTestUser()
        
        // Try to get ALL organizations
        const { data, count } = await client
          .from('organizations')
          .select('*', { count: 'exact' })

        // Should only see orgs user has access to
        if (count && count > 1) {
          console.log(`    User can access ${count} organizations (checking this is expected)`)
        }
      }
    )
  }

  /**
   * Test 12: Cross-Org Collaboration Vulnerabilities
   */
  async testCrossOrgCollaboration() {
    console.log('\nğŸ¤ Test 12: Cross-Org Collaboration Security')
    console.log('-'.repeat(70))

    await this.testSecurely(
      'Show collaborators can only access assigned shows',
      'medium',
      async () => {
        const serviceClient = dbManager.getServiceRoleClient()
        
        // Create org and show
        const { data: org } = await serviceClient
          .from('organizations')
          .insert({ name: 'Collab Test Org' })
          .select()
          .single()

        if (!org) return

        const { data: show } = await serviceClient
          .from('shows')
          .insert({
            org_id: org.id,
            title: 'Collab Test Show',
            date: '2025-12-01'
          })
          .select()
          .single()

        try {
          const { client, user } = await dbManager.createTestUser(
            `collab-test-${Date.now()}@example.com`
          )

          // Add as collaborator to this specific show
          await serviceClient.from('show_collaborators').insert({
            show_id: show!.id,
            user_id: user.id,
            role: 'editor'
          })

          // User should see this show
          const { data: accessibleShows } = await client
            .from('shows')
            .select('*')
            .eq('id', show!.id)

          if (!accessibleShows || accessibleShows.length === 0) {
            throw new Error('Collaborator cannot access assigned show!')
          }

          // User should NOT see other shows in the org
          const { data: otherShows } = await client
            .from('shows')
            .select('*')
            .neq('id', show!.id)
            .eq('org_id', org.id)

          if (otherShows && otherShows.length > 0) {
            throw new Error('Collaborator accessed non-assigned shows!')
          }
        } finally {
          if (!dbManager.isProduction()) {
            await serviceClient.from('show_collaborators').delete().eq('show_id', show!.id)
            await serviceClient.from('shows').delete().eq('id', show!.id)
            await serviceClient.from('organizations').delete().eq('id', org.id)
          }
        }
      }
    )
  }

  private printResults() {
    console.log('\n')
    console.log('='.repeat(70))
    console.log('ğŸ”’ RLS Security Test Summary')
    console.log('='.repeat(70))

    const passed = this.results.filter(r => r.passed).length
    const failed = this.results.filter(r => !r.passed).length

    console.log(`\nTotal Tests: ${this.results.length}`)
    console.log(`âœ… Passed: ${passed}`)
    console.log(`âŒ Failed: ${failed}`)

    // Group by severity
    const critical = this.results.filter(r => !r.passed && r.severity === 'critical')
    const high = this.results.filter(r => !r.passed && r.severity === 'high')
    const medium = this.results.filter(r => !r.passed && r.severity === 'medium')
    const low = this.results.filter(r => !r.passed && r.severity === 'low')

    if (failed > 0) {
      console.log('\nâŒ Security Vulnerabilities Found:')
      
      if (critical.length > 0) {
        console.log(`\n  ğŸ”´ CRITICAL (${critical.length}):`)
        critical.forEach(r => console.log(`    - ${r.testName}`))
      }
      
      if (high.length > 0) {
        console.log(`\n  ğŸŸ  HIGH (${high.length}):`)
        high.forEach(r => console.log(`    - ${r.testName}`))
      }
      
      if (medium.length > 0) {
        console.log(`\n  ğŸŸ¡ MEDIUM (${medium.length}):`)
        medium.forEach(r => console.log(`    - ${r.testName}`))
      }
      
      if (low.length > 0) {
        console.log(`\n  ğŸŸ¢ LOW (${low.length}):`)
        low.forEach(r => console.log(`    - ${r.testName}`))
      }
    } else {
      console.log('\nâœ… No security vulnerabilities detected!')
      console.log('   All RLS policies are working correctly.')
    }

    console.log('\n' + '='.repeat(70))
  }
}

// Run tests
const test = new RLSSecurityTest()
test.run().then(() => {
  console.log('\nâœ… Security tests complete!\n')
  process.exit(0)
}).catch(error => {
  console.error('\nâŒ Security test suite failed:', error)
  process.exit(1)
})
