"use client";

import { useState } from "react";
import { DateNavigator } from "../DateNavigator";
import { PersonScheduleSelector } from "../PersonScheduleSelector";
import { TimelineHoverPlaceholder } from "./TimelineHoverPlaceholder";
import { TimelineDragPreview } from "./TimelineDragPreview";
import { TimelineIntervals } from "./TimelineIntervals";
import { ScheduleEventItem } from "./ScheduleEventItem";
import { ScheduleEventDialog } from "./ScheduleEventDialog";

interface ScheduleItem {
  id: string;
  time: string;
  title: string;
  location?: string;
  type: "arrival" | "departure" | "show" | "venue" | "schedule";
  personId?: string;
  personName?: string;
  endTime?: string;
  notes?: string;
  itemType?: string | null;
  autoGenerated?: boolean;
}

interface ScheduleTimelineProps {
  scheduleItems: ScheduleItem[];
  currentDateStr: string;
  orgSlug: string;
  showId: string;
  onItemClick: (item: ScheduleItem) => void;
  onCreateItem: (data: {
    title: string;
    starts_at: string;
    ends_at: string | null;
    location: string | null;
    notes: string | null;
  }) => Promise<void>;
  onUpdateItem?: (
    itemId: string,
    itemType: string | null,
    autoGenerated: boolean,
    starts_at: string,
    ends_at: string | null
  ) => Promise<void>;
  onDeleteItem: (itemId: string) => Promise<void>;
  // Date navigation props
  currentDate?: Date;
  datesWithEvents?: string[];
  // Person selector props
  availablePeople?: Array<{
    id: string;
    name: string;
    duty: string | null;
  }>;
  selectedPeopleIds?: string[];
}

export function ScheduleTimeline({
  scheduleItems,
  currentDateStr,
  onCreateItem,
  onUpdateItem,
  onDeleteItem,
  currentDate,
  datesWithEvents = [],
  availablePeople = [],
  selectedPeopleIds = [],
}: ScheduleTimelineProps) {
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [editingItem, setEditingItem] = useState<ScheduleItem | null>(null);
  const [hoverPosition, setHoverPosition] = useState<number | null>(null);
  const [draggingItem, setDraggingItem] = useState<ScheduleItem | null>(null);
  const [itemWasDragged, setItemWasDragged] = useState(false);
  const [formData, setFormData] = useState({
    title: "",
    date: currentDateStr,
    starts_at: "",
    ends_at: "",
    location: "",
    notes: "",
  });

  //   const getItemColor = (type: string) => {
  //     switch (type) {
  //       case "arrival":
  //         return "bg-emerald-500/30 border-emerald-500/60 text-emerald-50";
  //       case "departure":
  //         return "bg-blue-500/30 border-blue-500/60 text-blue-50";
  //       case "show":
  //         return "bg-red-500/30 border-red-500/60 text-red-50";
  //       case "venue":
  //         return "bg-purple-500/30 border-purple-500/60 text-purple-50";
  //       case "schedule":
  //         return "bg-orange-500/30 border-orange-500/60 text-orange-50";
  //       default:
  //         return "bg-neutral-500/30 border-neutral-500/60 text-neutral-50";
  //     }
  //   };

  //   const getItemIcon = (type: string) => {
  //     switch (type) {
  //       case "arrival":
  //         return <PlaneLanding className="w-3.5 h-3.5" />;
  //       case "departure":
  //         return <Plane className="w-3.5 h-3.5" />;
  //       case "venue":
  //         return <MapPin className="w-3.5 h-3.5" />;
  //       case "show":
  //         return <Music className="w-3.5 h-3.5" />;
  //       case "schedule":
  //         return <MapPin className="w-3.5 h-3.5" />;
  //       default:
  //         return null;
  //     }
  //   };

  // Parse time from ISO string to minutes since midnight
  const parseTime = (timeStr: string) => {
    const date = new Date(timeStr);
    return date.getHours() * 60 + date.getMinutes();
  };

  // Show full 24 hours (0:00 to 23:00)
  const startTime = 0;
  const endTime = 1440; // 24 * 60 minutes

  // Generate hourly intervals (every 60 minutes)
  const intervals = [];
  for (let time = startTime; time < endTime; time += 60) {
    const hours = Math.floor(time / 60);
    intervals.push({
      time,
      label: `${hours.toString().padStart(2, "0")}:00`,
    });
  }

  // Compact spacing: 40px per hour = ~0.67px per minute
  // This gives us 960px total height (24h * 40px) instead of 1800px
  const pixelsPerHour = 40;
  const pixelsPerMinute = pixelsPerHour / 60;

  // Helper function to calculate snapped position from mouse event
  const calculateSnappedMinutes = (
    e: React.MouseEvent<HTMLDivElement>,
    rect: DOMRect
  ) => {
    const clickY = e.clientY - rect.top - 32;
    const minutes = Math.max(0, Math.round(clickY / pixelsPerMinute));
    return Math.round(minutes / 15) * 15;
  };

  // Function to open dialog with pre-filled time
  const handleTimelineClick = (e: React.MouseEvent<HTMLDivElement>) => {
    // Don't create new event if we just dragged something
    if (itemWasDragged) {
      return;
    }

    const target = e.target as HTMLElement;
    if (target.closest("[data-event-item]") || target.closest("button")) {
      return;
    }

    // Use the current hover position if available, otherwise calculate it
    const snappedMinutes =
      hoverPosition !== null
        ? hoverPosition
        : calculateSnappedMinutes(e, e.currentTarget.getBoundingClientRect());

    const hours = Math.floor(snappedMinutes / 60);
    const mins = snappedMinutes % 60;

    const timeStr = `${hours.toString().padStart(2, "0")}:${mins
      .toString()
      .padStart(2, "0")}`;

    // Calculate end time (1 hour after start)
    const endMinutes = snappedMinutes + 60;
    const endHours = Math.floor(endMinutes / 60);
    const endMins = endMinutes % 60;
    const endTimeStr = `${endHours.toString().padStart(2, "0")}:${endMins
      .toString()
      .padStart(2, "0")}`;

    setFormData({
      title: "",
      date: currentDateStr,
      starts_at: timeStr,
      ends_at: endTimeStr,
      location: "",
      notes: "",
    });
    setIsDialogOpen(true);
  };

  const handleTimelineMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    if (draggingItem) {
      const rect = e.currentTarget.getBoundingClientRect();
      const snappedMinutes = calculateSnappedMinutes(e, rect);
      const originalStartMinutes = parseTime(draggingItem.time);
      if (snappedMinutes !== originalStartMinutes) {
        setItemWasDragged(true);
      }
      setHoverPosition(snappedMinutes);
      return;
    }

    const target = e.target as HTMLElement;
    if (target.closest("[data-event-item]") || target.closest("button")) {
      setHoverPosition(null);
      return;
    }

    const rect = e.currentTarget.getBoundingClientRect();
    const snappedMinutes = calculateSnappedMinutes(e, rect);
    setHoverPosition(snappedMinutes);
  };

  const handleTimelineMouseLeave = () => {
    setHoverPosition(null);
  };

  const handleTimelineMouseUp = () => {
    if (draggingItem && itemWasDragged) {
      const startMinutes = parseTime(draggingItem.time);
      const endMinutes = draggingItem.endTime
        ? parseTime(draggingItem.endTime)
        : startMinutes + 60;
      const duration = endMinutes - startMinutes;

      const newStartMinutes = hoverPosition ?? startMinutes;
      const hours = Math.floor(newStartMinutes / 60);
      const mins = newStartMinutes % 60;
      const timeStr = `${hours.toString().padStart(2, "0")}:${mins
        .toString()
        .padStart(2, "0")}`;

      const endHours = Math.floor((newStartMinutes + duration) / 60);
      const endMins = (newStartMinutes + duration) % 60;
      const endTimeStr = `${endHours.toString().padStart(2, "0")}:${endMins
        .toString()
        .padStart(2, "0")}`;

      const startsAt = new Date(
        `${currentDateStr}T${timeStr}:00`
      ).toISOString();
      const endsAt = new Date(
        `${currentDateStr}T${endTimeStr}:00`
      ).toISOString();

      // If onUpdateItem is available and this is an auto-generated item, use it
      if (
        onUpdateItem &&
        draggingItem.autoGenerated &&
        (draggingItem.itemType === "hotel" ||
          draggingItem.itemType === "catering" ||
          draggingItem.itemType === "departure")
      ) {
        onUpdateItem(
          draggingItem.id,
          draggingItem.itemType,
          draggingItem.autoGenerated,
          startsAt,
          endsAt
        );
      } else {
        // Otherwise, delete and recreate (old behavior)
        onDeleteItem(draggingItem.id).then(() => {
          onCreateItem({
            title: draggingItem.title,
            starts_at: startsAt,
            ends_at: endsAt,
            location: draggingItem.location || null,
            notes: draggingItem.notes || null,
          });
        });
      }
    }

    setDraggingItem(null);
    setTimeout(() => setItemWasDragged(false), 300);
  };

  const handleItemMouseDown = (e: React.MouseEvent, item: ScheduleItem) => {
    e.stopPropagation();
    setDraggingItem(item);
  };

  const handleItemClick = (item: ScheduleItem) => {
    if (itemWasDragged) {
      return;
    }

    setEditingItem(item);
    const startTime = new Date(item.time);
    const timeStr = `${startTime
      .getHours()
      .toString()
      .padStart(2, "0")}:${startTime.getMinutes().toString().padStart(2, "0")}`;

    let endTimeStr = "";
    if (item.endTime) {
      const endTime = new Date(item.endTime);
      endTimeStr = `${endTime.getHours().toString().padStart(2, "0")}:${endTime
        .getMinutes()
        .toString()
        .padStart(2, "0")}`;
    }

    setFormData({
      title: item.title,
      date: currentDateStr,
      starts_at: timeStr,
      ends_at: endTimeStr,
      location: item.location || "",
      notes: item.notes || "",
    });
    setIsDialogOpen(true);
  };

  return (
    <div className="space-y-4 select-none">
      {/* Person Selector - Outside card */}
      {/* {currentDate && availablePeople.length > 0 && (
        <PersonScheduleSelector
          availablePeople={availablePeople}
          selectedPeopleIds={selectedPeopleIds}
        />
      )} */}

      {/* Timeline Section - Inside card */}
      <div className="bg-card border border-card-border rounded-[20px] p-5 space-y-3">
        <div className="flex items-center justify-between">
          <h3 className="text-xl font-medium text-card-foreground font-header">
            Schedule
          </h3>
          <ScheduleEventDialog
            isOpen={isDialogOpen}
            onOpenChange={setIsDialogOpen}
            editingItem={editingItem}
            formData={formData}
            onFormDataChange={setFormData}
            onSubmit={async () => {
              const startsAt = new Date(
                `${formData.date}T${formData.starts_at}:00`
              ).toISOString();
              const endsAt = formData.ends_at
                ? new Date(
                    `${formData.date}T${formData.ends_at}:00`
                  ).toISOString()
                : null;

              if (editingItem) {
                await onDeleteItem(editingItem.id);
              }

              await onCreateItem({
                title: formData.title,
                starts_at: startsAt,
                ends_at: endsAt,
                location: formData.location || null,
                notes: formData.notes || null,
              });

              setFormData({
                title: "",
                date: currentDateStr,
                starts_at: "",
                ends_at: "",
                location: "",
                notes: "",
              });
              setEditingItem(null);
              setIsDialogOpen(false);
            }}
            onDelete={async (itemId) => {
              await onDeleteItem(itemId);
              setIsDialogOpen(false);
              setEditingItem(null);
              setFormData({
                title: "",
                date: currentDateStr,
                starts_at: "",
                ends_at: "",
                location: "",
                notes: "",
              });
            }}
          />
        </div>

        {/* Date Navigator */}
        {currentDate && (
          <div className="flex items-center justify-between">
            <DateNavigator
              currentDate={currentDate}
              datesWithEvents={datesWithEvents}
            />
          </div>
        )}

        {/* Timeline View */}
        <div
          className="relative rounded-lg cursor-crosshair"
          onClick={handleTimelineClick}
          onMouseMove={handleTimelineMouseMove}
          onMouseLeave={handleTimelineMouseLeave}
          onMouseUp={handleTimelineMouseUp}
          style={{
            minHeight: `${(endTime - startTime) * pixelsPerMinute + 32}px`,
          }}
        >
          {/* Hover placeholder */}
          {hoverPosition !== null && !draggingItem && (
            <TimelineHoverPlaceholder
              hoverPosition={hoverPosition}
              pixelsPerMinute={pixelsPerMinute}
            />
          )}

          {/* Drag preview */}
          {draggingItem && hoverPosition !== null && (
            <TimelineDragPreview
              draggingItem={draggingItem}
              hoverPosition={hoverPosition}
              pixelsPerMinute={pixelsPerMinute}
              parseTime={parseTime}
            />
          )}
          {/* Time intervals */}
          <TimelineIntervals
            intervals={intervals}
            startTime={startTime}
            pixelsPerMinute={pixelsPerMinute}
          />

          {/* Activity boxes */}
          {scheduleItems.map((item) => {
            const startMinutes = parseTime(item.time);
            const endMinutes = item.endTime
              ? parseTime(item.endTime)
              : startMinutes + 30;
            const duration = endMinutes - startMinutes;
            const topPosition =
              (startMinutes - startTime) * pixelsPerMinute + 32;
            const height = duration * pixelsPerMinute;

            return (
              <ScheduleEventItem
                key={item.id}
                item={item}
                topPosition={topPosition}
                height={height}
                isDragging={draggingItem?.id === item.id}
                onMouseDown={handleItemMouseDown}
                onClick={handleItemClick}
                onDelete={onDeleteItem}
              />
            );
          })}
        </div>
      </div>
    </div>
  );
}
