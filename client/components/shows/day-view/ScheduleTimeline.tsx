"use client";

import { useState, useEffect, useRef } from "react";
import { DateNavigator } from "../DateNavigator";
// import { PersonScheduleSelector } from "../PersonScheduleSelector";
import { TimelineHoverPlaceholder } from "./TimelineHoverPlaceholder";
import { TimelineDragPreview } from "./TimelineDragPreview";
import { TimelineIntervals } from "./TimelineIntervals";
import { ScheduleEventItem } from "./ScheduleEventItem";
import { ScheduleEventDialog } from "./ScheduleEventDialog";

interface ScheduleItem {
  id: string;
  time: string;
  title: string;
  location?: string;
  type: "arrival" | "departure" | "show" | "venue" | "schedule";
  personId?: string;
  personName?: string;
  endTime?: string;
  notes?: string;
  itemType?: string | null;
  autoGenerated?: boolean;
}

interface ScheduleTimelineProps {
  scheduleItems: ScheduleItem[];
  currentDateStr: string;
  orgSlug: string;
  showId: string;
  onItemClick: (item: ScheduleItem) => void;
  onCreateItem: (data: {
    title: string;
    starts_at: string;
    ends_at: string | null;
    location: string | null;
    notes: string | null;
  }) => Promise<void>;
  onUpdateItem?: (
    itemId: string,
    itemType: string | null,
    autoGenerated: boolean,
    starts_at: string,
    ends_at: string | null
  ) => Promise<void>;
  onDeleteItem: (itemId: string) => Promise<void>;
  // Date navigation props
  currentDate?: Date;
  datesWithEvents?: string[];
  // Person selector props
  availablePeople?: Array<{
    id: string;
    name: string;
    duty: string | null;
  }>;
  selectedPeopleIds?: string[];
}

export function ScheduleTimeline({
  scheduleItems,
  currentDateStr,
  onCreateItem,
  onUpdateItem,
  onDeleteItem,
  currentDate,
  datesWithEvents = [],
}: // availablePeople = [],
// selectedPeopleIds = [],
ScheduleTimelineProps) {
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [editingItem, setEditingItem] = useState<ScheduleItem | null>(null);
  const [hoverPosition, setHoverPosition] = useState<number | null>(null);
  const [draggingItem, setDraggingItem] = useState<ScheduleItem | null>(null);
  const [itemWasDragged, setItemWasDragged] = useState(false);
  const [formData, setFormData] = useState({
    title: "",
    date: currentDateStr,
    starts_at: "",
    ends_at: "",
    location: "",
    notes: "",
  });

  const scrollContainerRef = useRef<HTMLDivElement>(null);

  // Parse time from ISO string to minutes since midnight
  const parseTime = (timeStr: string) => {
    const date = new Date(timeStr);
    return date.getHours() * 60 + date.getMinutes();
  };

  // Show full 24 hours (0:00 to 23:00)
  const startTime = 0;
  const endTime = 1440; // 24 * 60 minutes

  // Generate hourly intervals (every 60 minutes)
  const intervals = [];
  for (let time = startTime; time < endTime; time += 60) {
    const hours = Math.floor(time / 60);
    intervals.push({
      time,
      label: `${hours.toString().padStart(2, "0")}:00`,
    });
  }

  // Compact spacing: 40px per hour = ~0.67px per minute
  // This gives us 960px total height (24h * 40px) instead of 1800px
  const pixelsPerHour = 40;
  const pixelsPerMinute = pixelsPerHour / 60;

  // Auto-scroll to first event on mount or when scheduleItems change
  useEffect(() => {
    if (scheduleItems.length > 0 && scrollContainerRef.current) {
      // Find the earliest event
      const earliestItem = scheduleItems.reduce((earliest, current) => {
        return new Date(current.time) < new Date(earliest.time)
          ? current
          : earliest;
      });

      const earliestMinutes = parseTime(earliestItem.time);
      const scrollPosition = (earliestMinutes - startTime) * pixelsPerMinute;

      // Scroll with a small offset to show some context above the event
      const offset = 100; // 100px above the event
      scrollContainerRef.current.scrollTop = Math.max(
        0,
        scrollPosition - offset
      );
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [scheduleItems.length, currentDateStr]); // Re-run when items change or date changes

  // Helper function to calculate snapped position from mouse event
  const calculateSnappedMinutes = (
    e: React.MouseEvent<HTMLDivElement>,
    rect: DOMRect
  ) => {
    const clickY = e.clientY - rect.top - 32;
    const minutes = Math.max(0, Math.round(clickY / pixelsPerMinute));
    return Math.round(minutes / 15) * 15;
  };

  // Function to open dialog with pre-filled time
  const handleTimelineClick = (e: React.MouseEvent<HTMLDivElement>) => {
    // Don't create new event if we just dragged something
    if (itemWasDragged) {
      return;
    }

    const target = e.target as HTMLElement;
    if (target.closest("[data-event-item]") || target.closest("button")) {
      return;
    }

    // Use the current hover position if available, otherwise calculate it
    const snappedMinutes =
      hoverPosition !== null
        ? hoverPosition
        : calculateSnappedMinutes(e, e.currentTarget.getBoundingClientRect());

    const hours = Math.floor(snappedMinutes / 60);
    const mins = snappedMinutes % 60;

    const timeStr = `${hours.toString().padStart(2, "0")}:${mins
      .toString()
      .padStart(2, "0")}`;

    // Calculate end time (1 hour after start)
    const endMinutes = snappedMinutes + 60;
    const endHours = Math.floor(endMinutes / 60);
    const endMins = endMinutes % 60;
    const endTimeStr = `${endHours.toString().padStart(2, "0")}:${endMins
      .toString()
      .padStart(2, "0")}`;

    setFormData({
      title: "",
      date: currentDateStr,
      starts_at: timeStr,
      ends_at: endTimeStr,
      location: "",
      notes: "",
    });
    setIsDialogOpen(true);
  };

  const handleTimelineMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    if (draggingItem) {
      const rect = e.currentTarget.getBoundingClientRect();
      const snappedMinutes = calculateSnappedMinutes(e, rect);
      const originalStartMinutes = parseTime(draggingItem.time);
      if (snappedMinutes !== originalStartMinutes) {
        setItemWasDragged(true);
      }
      setHoverPosition(snappedMinutes);
      return;
    }

    const target = e.target as HTMLElement;
    if (target.closest("[data-event-item]") || target.closest("button")) {
      setHoverPosition(null);
      return;
    }

    const rect = e.currentTarget.getBoundingClientRect();
    const snappedMinutes = calculateSnappedMinutes(e, rect);
    setHoverPosition(snappedMinutes);
  };

  const handleTimelineMouseLeave = () => {
    setHoverPosition(null);
  };

  const handleTimelineMouseUp = () => {
    if (draggingItem && itemWasDragged) {
      const startMinutes = parseTime(draggingItem.time);
      const endMinutes = draggingItem.endTime
        ? parseTime(draggingItem.endTime)
        : startMinutes + 60;
      const duration = endMinutes - startMinutes;

      const newStartMinutes = hoverPosition ?? startMinutes;
      const hours = Math.floor(newStartMinutes / 60);
      const mins = newStartMinutes % 60;
      const timeStr = `${hours.toString().padStart(2, "0")}:${mins
        .toString()
        .padStart(2, "0")}`;

      const endHours = Math.floor((newStartMinutes + duration) / 60);
      const endMins = (newStartMinutes + duration) % 60;
      const endTimeStr = `${endHours.toString().padStart(2, "0")}:${endMins
        .toString()
        .padStart(2, "0")}`;

      const startsAt = new Date(
        `${currentDateStr}T${timeStr}:00`
      ).toISOString();
      const endsAt = new Date(
        `${currentDateStr}T${endTimeStr}:00`
      ).toISOString();

      // If onUpdateItem is available and this is an auto-generated item, use it
      if (
        onUpdateItem &&
        draggingItem.autoGenerated &&
        (draggingItem.itemType === "hotel" ||
          draggingItem.itemType === "catering" ||
          draggingItem.itemType === "departure")
      ) {
        onUpdateItem(
          draggingItem.id,
          draggingItem.itemType,
          draggingItem.autoGenerated,
          startsAt,
          endsAt
        );
      } else {
        // Otherwise, delete and recreate (old behavior)
        onDeleteItem(draggingItem.id).then(() => {
          onCreateItem({
            title: draggingItem.title,
            starts_at: startsAt,
            ends_at: endsAt,
            location: draggingItem.location || null,
            notes: draggingItem.notes || null,
          });
        });
      }
    }

    setDraggingItem(null);
    setTimeout(() => setItemWasDragged(false), 300);
  };

  const handleItemMouseDown = (e: React.MouseEvent, item: ScheduleItem) => {
    e.stopPropagation();
    setDraggingItem(item);
  };

  const handleItemClick = (item: ScheduleItem) => {
    if (itemWasDragged) {
      return;
    }

    setEditingItem(item);
    const startTime = new Date(item.time);
    const timeStr = `${startTime
      .getHours()
      .toString()
      .padStart(2, "0")}:${startTime.getMinutes().toString().padStart(2, "0")}`;

    let endTimeStr = "";
    if (item.endTime) {
      const endTime = new Date(item.endTime);
      endTimeStr = `${endTime.getHours().toString().padStart(2, "0")}:${endTime
        .getMinutes()
        .toString()
        .padStart(2, "0")}`;
    }

    setFormData({
      title: item.title,
      date: currentDateStr,
      starts_at: timeStr,
      ends_at: endTimeStr,
      location: item.location || "",
      notes: item.notes || "",
    });
    setIsDialogOpen(true);
  };

  return (
    <div className="select-none h-full flex flex-col">
      {/* Person Selector - Outside card */}
      {/* {currentDate && availablePeople.length > 0 && (
        <PersonScheduleSelector
          availablePeople={availablePeople}
          selectedPeopleIds={selectedPeopleIds}
        />
      )} */}

      {/* Timeline Section - Inside card */}
      <div className="bg-card border border-card-border rounded-[20px] flex flex-col h-full overflow-hidden">
        <div className="flex-shrink-0 p-5 pb-3">
          <div className="flex items-center justify-between mb-3">
            <h3 className="text-xl font-medium text-card-foreground font-header">
              Schedule
            </h3>
            <ScheduleEventDialog
              isOpen={isDialogOpen}
              onOpenChange={setIsDialogOpen}
              editingItem={editingItem}
              formData={formData}
              onFormDataChange={setFormData}
              onSubmit={async () => {
                try {
                  const startsAt = new Date(
                    `${formData.date}T${formData.starts_at}:00`
                  ).toISOString();
                  const endsAt = formData.ends_at
                    ? new Date(
                        `${formData.date}T${formData.ends_at}:00`
                      ).toISOString()
                    : null;

                  if (editingItem) {
                    await onDeleteItem(editingItem.id);
                  }

                  await onCreateItem({
                    title: formData.title,
                    starts_at: startsAt,
                    ends_at: endsAt,
                    location: formData.location || null,
                    notes: formData.notes || null,
                  });

                  setFormData({
                    title: "",
                    date: currentDateStr,
                    starts_at: "",
                    ends_at: "",
                    location: "",
                    notes: "",
                  });
                  setEditingItem(null);
                  setIsDialogOpen(false);
                } catch (error) {
                  // Error is already shown by the parent component
                  console.error("Failed to create schedule item:", error);
                }
              }}
              onDelete={async (itemId) => {
                await onDeleteItem(itemId);
                setIsDialogOpen(false);
                setEditingItem(null);
                setFormData({
                  title: "",
                  date: currentDateStr,
                  starts_at: "",
                  ends_at: "",
                  location: "",
                  notes: "",
                });
              }}
            />
          </div>

          {/* Date Navigator */}
          {currentDate && (
            <div className="flex items-center justify-between">
              <DateNavigator
                currentDate={currentDate}
                datesWithEvents={datesWithEvents}
              />
            </div>
          )}
        </div>

        {/* Timeline View - Scrollable */}
        <div
          ref={scrollContainerRef}
          className="flex-1 overflow-y-auto px-5 pb-5"
        >
          <div
            className="relative rounded-lg cursor-crosshair"
            onClick={handleTimelineClick}
            onMouseMove={handleTimelineMouseMove}
            onMouseLeave={handleTimelineMouseLeave}
            onMouseUp={handleTimelineMouseUp}
            style={{
              minHeight: `${(endTime - startTime) * pixelsPerMinute + 32}px`,
            }}
          >
            {/* Hover placeholder */}
            {hoverPosition !== null && !draggingItem && (
              <TimelineHoverPlaceholder
                hoverPosition={hoverPosition}
                pixelsPerMinute={pixelsPerMinute}
              />
            )}

            {/* Drag preview */}
            {draggingItem && hoverPosition !== null && (
              <TimelineDragPreview
                draggingItem={draggingItem}
                hoverPosition={hoverPosition}
                pixelsPerMinute={pixelsPerMinute}
                parseTime={parseTime}
              />
            )}
            {/* Time intervals */}
            <TimelineIntervals
              intervals={intervals}
              startTime={startTime}
              pixelsPerMinute={pixelsPerMinute}
            />

            {/* Activity boxes */}
            {scheduleItems.map((item) => {
              const startMinutes = parseTime(item.time);
              const endMinutes = item.endTime
                ? parseTime(item.endTime)
                : startMinutes + 30;
              const duration = endMinutes - startMinutes;
              const topPosition =
                (startMinutes - startTime) * pixelsPerMinute + 32;
              const height = duration * pixelsPerMinute;

              return (
                <ScheduleEventItem
                  key={item.id}
                  item={item}
                  topPosition={topPosition}
                  height={height}
                  isDragging={draggingItem?.id === item.id}
                  onMouseDown={handleItemMouseDown}
                  onClick={handleItemClick}
                  onDelete={onDeleteItem}
                />
              );
            })}
          </div>
        </div>
      </div>
    </div>
  );
}
