/// Models for the show day view
/// Mirrors the data structure from the web client's CalendarDayView

/// Schedule item (Airport Pickup, Sound Check, etc.)
class ScheduleItem {
  final String id;
  final String title;
  final String startTime;
  final String? endTime;
  final String? location;
  final String? notes;
  final String type; // 'schedule', 'doors', 'show', 'arrival', 'departure', etc.
  final bool autoGenerated;

  ScheduleItem({
    required this.id,
    required this.title,
    required this.startTime,
    this.endTime,
    this.location,
    this.notes,
    this.type = 'schedule',
    this.autoGenerated = false,
  });

  factory ScheduleItem.fromJson(Map<String, dynamic> json) {
    return ScheduleItem(
      id: json['id'] as String,
      title: json['title'] as String,
      startTime: json['starts_at'] as String,
      endTime: json['ends_at'] as String?,
      location: json['location'] as String?,
      notes: json['notes'] as String?,
      type: json['item_type'] as String? ?? 'schedule',
      autoGenerated: json['auto_generated'] as bool? ?? false,
    );
  }

  /// Format time for display (e.g., "11:00")
  String get formattedStartTime {
    try {
      final dt = DateTime.parse(startTime);
      return '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    } catch (_) {
      return startTime;
    }
  }

  String? get formattedEndTime {
    if (endTime == null) return null;
    try {
      final dt = DateTime.parse(endTime!);
      return '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    } catch (_) {
      return endTime;
    }
  }

  String get timeRange {
    if (formattedEndTime != null) {
      return '$formattedStartTime - $formattedEndTime';
    }
    return formattedStartTime;
  }
}

/// Flight information
class FlightInfo {
  final String id;
  final String direction; // 'arrival' or 'departure'
  final String? airline;
  final String? flightNumber;
  final String? bookingRef;
  final String? ticketNumber;
  final String? aircraftModel;
  final String? departAirportCode;
  final String? departCity;
  final String? departAt;
  final String? arrivalAirportCode;
  final String? arrivalCity;
  final String? arrivalAt;
  final String? seatNumber;
  final String? travelClass;
  final String? personId;

  FlightInfo({
    required this.id,
    required this.direction,
    this.airline,
    this.flightNumber,
    this.bookingRef,
    this.ticketNumber,
    this.aircraftModel,
    this.departAirportCode,
    this.departCity,
    this.departAt,
    this.arrivalAirportCode,
    this.arrivalCity,
    this.arrivalAt,
    this.seatNumber,
    this.travelClass,
    this.personId,
  });

  factory FlightInfo.fromJson(Map<String, dynamic> json) {
    return FlightInfo(
      id: json['id'] as String,
      direction: json['direction'] as String? ?? 'departure',
      airline: json['airline'] as String?,
      flightNumber: json['flight_number'] as String?,
      bookingRef: json['booking_ref'] as String?,
      ticketNumber: json['ticket_number'] as String?,
      aircraftModel: json['aircraft_model'] as String?,
      departAirportCode: json['depart_airport_code'] as String?,
      departCity: json['depart_city'] as String?,
      departAt: json['depart_at'] as String?,
      arrivalAirportCode: json['arrival_airport_code'] as String?,
      arrivalCity: json['arrival_city'] as String?,
      arrivalAt: json['arrival_at'] as String?,
      seatNumber: json['seat_number'] as String?,
      travelClass: json['travel_class'] as String?,
      personId: json['person_id'] as String?,
    );
  }

  String get displayFlightNumber => flightNumber ?? 'Flight';
  
  String get route => '${departAirportCode ?? '???'} â†’ ${arrivalAirportCode ?? '???'}';
  
  String? get formattedDepartTime {
    if (departAt == null) return null;
    try {
      final dt = DateTime.parse(departAt!);
      return '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    } catch (_) {
      return null;
    }
  }

  String? get formattedArrivalTime {
    if (arrivalAt == null) return null;
    try {
      final dt = DateTime.parse(arrivalAt!);
      return '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    } catch (_) {
      return null;
    }
  }

  String? get duration {
    if (departAt == null || arrivalAt == null) return null;
    try {
      final depart = DateTime.parse(departAt!);
      final arrive = DateTime.parse(arrivalAt!);
      final diff = arrive.difference(depart);
      final hours = diff.inHours;
      final minutes = diff.inMinutes % 60;
      return '${hours}h ${minutes}min';
    } catch (_) {
      return null;
    }
  }
}

/// Hotel/Lodging information
class LodgingInfo {
  final String id;
  final String? hotelName;
  final String? address;
  final String? city;
  final String? checkInAt;
  final String? checkOutAt;
  final List<String>? bookingRefs;
  final String? phone;
  final String? email;
  final String? notes;

  LodgingInfo({
    required this.id,
    this.hotelName,
    this.address,
    this.city,
    this.checkInAt,
    this.checkOutAt,
    this.bookingRefs,
    this.phone,
    this.email,
    this.notes,
  });

  factory LodgingInfo.fromJson(Map<String, dynamic> json) {
    return LodgingInfo(
      id: json['id'] as String,
      hotelName: json['hotel_name'] as String?,
      address: json['address'] as String?,
      city: json['city'] as String?,
      checkInAt: json['check_in_at'] as String?,
      checkOutAt: json['check_out_at'] as String?,
      bookingRefs: (json['booking_refs'] as List<dynamic>?)?.cast<String>(),
      phone: json['phone'] as String?,
      email: json['email'] as String?,
      notes: json['notes'] as String?,
    );
  }

  String? get formattedCheckIn {
    if (checkInAt == null) return null;
    try {
      final dt = DateTime.parse(checkInAt!);
      return '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    } catch (_) {
      return checkInAt;
    }
  }

  String? get formattedCheckOut {
    if (checkOutAt == null) return null;
    try {
      final dt = DateTime.parse(checkOutAt!);
      return '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    } catch (_) {
      return checkOutAt;
    }
  }

  String? get timeRange {
    if (formattedCheckIn != null && formattedCheckOut != null) {
      return '$formattedCheckIn - $formattedCheckOut';
    }
    return formattedCheckIn ?? formattedCheckOut;
  }
}

/// Catering/Restaurant information
class CateringInfo {
  final String id;
  final String? providerName;
  final String? address;
  final String? city;
  final String? serviceAt;
  final int? guestCount;
  final List<String>? bookingRefs;
  final String? phone;
  final String? email;
  final String? notes;

  CateringInfo({
    required this.id,
    this.providerName,
    this.address,
    this.city,
    this.serviceAt,
    this.guestCount,
    this.bookingRefs,
    this.phone,
    this.email,
    this.notes,
  });

  factory CateringInfo.fromJson(Map<String, dynamic> json) {
    return CateringInfo(
      id: json['id'] as String,
      providerName: json['provider_name'] as String?,
      address: json['address'] as String?,
      city: json['city'] as String?,
      serviceAt: json['service_at'] as String?,
      guestCount: json['guest_count'] as int?,
      bookingRefs: (json['booking_refs'] as List<dynamic>?)?.cast<String>(),
      phone: json['phone'] as String?,
      email: json['email'] as String?,
      notes: json['notes'] as String?,
    );
  }

  String? get formattedServiceTime {
    if (serviceAt == null) return null;
    try {
      final dt = DateTime.parse(serviceAt!);
      return '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    } catch (_) {
      return serviceAt;
    }
  }
}

/// Contact information
class ContactInfo {
  final String id;
  final String name;
  final String? role;
  final String? phone;
  final String? email;
  final bool isPromoter;

  ContactInfo({
    required this.id,
    required this.name,
    this.role,
    this.phone,
    this.email,
    this.isPromoter = false,
  });

  factory ContactInfo.fromJson(Map<String, dynamic> json) {
    return ContactInfo(
      id: json['id'] as String,
      name: json['name'] as String,
      role: json['role'] as String?,
      phone: json['phone'] as String?,
      email: json['email'] as String?,
      isPromoter: json['is_promoter'] as bool? ?? false,
    );
  }
}

/// Document/File information (from files table)
class DocumentInfo {
  final String id;
  final String storagePath;
  final String? originalName;
  final String? contentType;
  final int? sizeBytes;

  DocumentInfo({
    required this.id,
    required this.storagePath,
    this.originalName,
    this.contentType,
    this.sizeBytes,
  });

  factory DocumentInfo.fromJson(Map<String, dynamic> json) {
    return DocumentInfo(
      id: json['id'] as String,
      storagePath: json['storage_path'] as String,
      originalName: json['original_name'] as String?,
      contentType: json['content_type'] as String?,
      sizeBytes: json['size_bytes'] as int?,
    );
  }
  
  /// Check if this is an image file
  bool get isImage {
    final ct = contentType?.toLowerCase() ?? '';
    return ct.startsWith('image/');
  }
  
  /// Check if this is a PDF file
  bool get isPdf {
    final ct = contentType?.toLowerCase() ?? '';
    return ct.contains('pdf');
  }
  
  /// Get display name
  String get displayName => originalName ?? 'Document';
  
  /// Format file size for display
  String get formattedSize {
    if (sizeBytes == null) return '';
    if (sizeBytes! < 1024) return '$sizeBytes B';
    if (sizeBytes! < 1024 * 1024) return '${(sizeBytes! / 1024).toStringAsFixed(1)} KB';
    return '${(sizeBytes! / (1024 * 1024)).toStringAsFixed(1)} MB';
  }
}

/// Guestlist entry information
class GuestInfo {
  final String id;
  final String name;
  final String? phone;
  final String? email;
  final int guestCount;
  final String? passType;
  final String? notes;

  GuestInfo({
    required this.id,
    required this.name,
    this.phone,
    this.email,
    this.guestCount = 1,
    this.passType,
    this.notes,
  });

  factory GuestInfo.fromJson(Map<String, dynamic> json) {
    return GuestInfo(
      id: json['id'] as String,
      name: json['name'] as String,
      phone: json['phone'] as String?,
      email: json['email'] as String?,
      guestCount: json['guest_count'] as int? ?? 1,
      passType: json['pass_type'] as String?,
      notes: json['notes'] as String?,
    );
  }
}

/// Assigned person
class AssignedPerson {
  final String personId;
  final String name;
  final String? duty;
  final String? memberType;

  AssignedPerson({
    required this.personId,
    required this.name,
    this.duty,
    this.memberType,
  });

  factory AssignedPerson.fromJson(Map<String, dynamic> json) {
    final people = json['people'] as Map<String, dynamic>?;
    return AssignedPerson(
      personId: json['person_id'] as String,
      name: people?['name'] as String? ?? 'Unknown',
      duty: json['duty'] as String?,
      memberType: people?['member_type'] as String?,
    );
  }

  bool get isArtist => memberType == 'artist';
}

/// Complete show day data
class ShowDayData {
  final String showId;
  final String title;
  final DateTime date;
  final String? doorsAt;
  final String? setTime;
  final String? venueName;
  final String? venueCity;
  final List<AssignedPerson> assignedPeople;
  final List<ScheduleItem> scheduleItems;
  final List<FlightInfo> flights;
  final List<LodgingInfo> lodging;
  final List<CateringInfo> catering;
  final List<ContactInfo> contacts;
  final List<DocumentInfo> documents;

  ShowDayData({
    required this.showId,
    required this.title,
    required this.date,
    this.doorsAt,
    this.setTime,
    this.venueName,
    this.venueCity,
    this.assignedPeople = const [],
    this.scheduleItems = const [],
    this.flights = const [],
    this.lodging = const [],
    this.catering = const [],
    this.contacts = const [],
    this.documents = const [],
  });

  /// Get artists from assigned people
  List<AssignedPerson> get artists =>
      assignedPeople.where((p) => p.isArtist).toList();

  /// Get artist names as comma-separated string
  String get artistNames {
    final names = artists.map((a) => a.name).toList();
    return names.isNotEmpty ? names.join(', ') : 'No Artist';
  }

  /// Format date for display (e.g., "Thurs 19:30")
  String get formattedDay {
    const days = ['Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat', 'Sun'];
    return days[date.weekday - 1];
  }

  /// Format full date (e.g., "22 July 2025")
  String get formattedDate {
    const months = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    return '${date.day} ${months[date.month - 1]} ${date.year}';
  }

  /// Format set time for display
  String? get formattedSetTime {
    if (setTime == null) return null;
    try {
      final dt = DateTime.parse(setTime!);
      return '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    } catch (_) {
      return setTime;
    }
  }

  /// Get header info (day + time)
  String get headerInfo {
    final time = formattedSetTime ?? '';
    return '$formattedDay ${time.isNotEmpty ? time : ''}';
  }
}
